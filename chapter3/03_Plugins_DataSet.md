# 数据集

为了便于数据的获取，使用Macula的各种混搭技术，我们引入了数据集的方式来产生数据集合。

数据集具有以下的特点：

1. 数据源可以基于不同的数据库，但每个数据集只能最多使用一个数据源；
2. 数据集可以配置多个不同的串行处理器；
3. 数据集可以通过编程接口编写，也可以通过XML的方式配置；

## 16.1 数据源（DataSource）

数据源表示一种数据来源。当前的数据源支持两种来源方式：

1. 数据库

    通过设定Java JDBC所需要的元素，来获取数据库连接。在JDBC环境下，可以设置两种类型的数据库连接：JNDI配置的容器级的数据源和通过JDBC创建的数据源。
    
2. LDAP

## 16.2 数据集（DataSet）

数据集表示通过数据源获取一个数据的集合。它主要由表达式、处理器链、数据源三部分来确定数据集的内容。

1. 表达式
    
    表达式可以是一个SQL语句，也可以是包含了Freemarker、Spring EL等表达式的混搭模式的字符串，表达式的内容是任意的，只要下面提到的处理器能处理。需要注意的事DataSet的目的是为了提供一个数据集合，所以表达式往往是一个SQL Select语句。

    在特殊情况下，数据集是静态的Key-Value集合，此时数据集可以不需要引用数据源（详见StaticOptionsDataHandler的介绍）。
    
2. 处理器链

    之所以称为处理器链，是因为它是由多个处理器有序的组合在一起形成的。处理器是一个org.macula.base.data.handle.DataHandler接口的实现，可以自定义一些处理器实现，对于Macula已实现的处理器有：
    
    * StaticOptionsDataHandler：
    
    最简单的处理器，是将表达按|分隔，每一部分作为集合中的一个元素从而形成的数据集合。在元素内部，继续按:分隔成Object[]数组，从而形成整个数据集。
    
    例如表达式为：
    
    ```
    name:Wilson|name:Jokeway
    ```
    
    形成的最终数据集为：
    ```java
    List<Object[]> {
        Object[] { "name", "Wilson"},
        Object[] { "name", "Jokeway"}
    }
    ```
    
    ***注意***
    
    *如果DataSet没有指定任何处理器链，并且没有指定数据源，将默认使用该处理器来获取数据结果集。*
    
    * FreemarkerDataHandler
    
    该处理器将输入的表达式当作Freemarker的片段来处理，完全遵循Freemarker的语法。由于在处理器中，总是传入了UserContext上下文，所以在Freemarker表达式中，默认可以使用的有user变量，以及UserContext中可被解析的变量，均可在Freemarker表达式中解析。

    例如，UserContext中的user为{name: Jokeway}，并且能够解析Country属性为String("China")，那么下面的表达式：
    
    ```
    我的名字是${user.name}
    <#if xyz == 'China'>
       ，你好来自中国的朋友！
    </#if>
    ```
    
    将被最终解析为：
    
    ```
    我的名字是Jokeway
    ，你好来自中国的朋友！
    ```
    
    * QueryParserDataHandler
    
    该处理器是基于Macula的语法解析方式进行解析。Macula的表达式基于Spring EL，并在Spring EL的基础上加入了自定义部分，具体如下：
    
        * \#(表达式)#
        
        这种写法，Macula认为需要将表达式解析为动态的一个变量替换（如：ptoken1)，并将表达式的结果与该变量名放入到UserContext的Map中，形成{ptoken1: 表达式的值}的方式。
        
        ***注意***
        
        *一般来讲，这类方式用来处理SQL语句中的条件部分，可以通过JDBC的setParameter方式来设置参数值的情况下使用。*
        
        * \#[表达式]#
        
        这种写法，Macula认为需要将表达式解析为一个字符串。

        例如，假如UserContext中能将China变量解析为"中国"，那么：
        
        ```
        我是#[China]#人
        ```
        将被解析为：
        ```
        我是中国人
        ```
        如果表达式解析出来是一个集合，则将集合中的元素以逗号分隔的形式展开（主要是基于SQL的特点才这样设计），还是上面的例子，如果China解析出来为`List<Integer>{1,2,3}`，那么整个结果将被解析为：
        ```
        我是1,2,3人
        ```
        * \#['表达式']#
        
        Macula之所以提供这个表达式，主要用于SQL语句解析时，使用IN条件下，需要为表达式中的每个数据都增加引号的情况。

        还是上面的例子，如果使用：
        
        ```
        我是#['China']#人
        ```
        将被解析为：
        ```
        我是'中国'人
        ```
        和
        ```
        我是'1','2','3'人
        ```
        ***注意***
        
        *这种方式在SQL中IN操作情况下特别有用。*
        
    ***重要***
    
    *该处理器所处理过的字符串均经过了SQL的过滤处理，即会将'替换为''，以避免SQL注入的风险。当然，为了尽可能的避免SQL注入风险，在可以使用#()#的地方，不要使用#[]#。*
    
    * QueryExecutorHandler
    
    对SQL语句表达式来说，最核心的处理器，经过该处理器的处理后，将SQL语句变为执行的结果数据集。
    
3. 处理器链的配置

    在DataSet未明确指定处理器链时，所使用的处理器链为：
    
    * 没有设置数据源：StaticOptionsDataHandler
    * 设置了数据源：FreemarkerDataHandler、QueryParserDataHandler、QueryExecutorHandler
    
    在DataSet的API中，getHandlerChain得到的数据格式如下（基于XStream）：

    ```xml
    <list>
    <HandlerEntry>
        <className>org.macula.base.data.handle.impl.FreemarkerDataHandler</className>
    </HandlerEntry>
    <HandlerEntry>
        <className>org.macula.base.data.handle.impl.QueryParserDataHandler</className>
    </HandlerEntry>
    <HandlerEntry>
        <className>org.macula.base.data.handle.impl.QueryExecutorHandler</className>
    </HandlerEntry>
    </list>
    ```

## 16.3 数据集参数（DataArg）

为了显式标识DataSet详细需要的参数（表达式中使用到的变量），可以设置数据集所需要的参数（DataArg），它主要有以下几个作用：

1. 显式标注变量的数据类型；
2. 可用于将界面输入的条件转化为具体所需的数据类型；
3. 可以设置参数的缺省值。

***注意***

*如果仅仅是为了使用DataSet数据集，DataArg几乎没有什么用，仅仅是为了后期的功能扩展预留。*

## 16.4 数据集的定义方式

数据集（包括数据源）有多种方式可以配置，这是由DataLoader接口的实现去独立完成从各指定的位置获取的。当前大致有两种方式：

1. 基于数据库定义

    用户可通过维护界面（Plugins项目将会提供管理界面）来对数据集进行维护，其实质内容是在数据库层面增加DataSet表的记录，从而达到DataSet的定义目的。
    
2. 基于XML定义

    考虑到数据集定义的可移植性，以及各系统间同步时的便捷性，增加了DataSet的XML定义方式。其定义模型参考了Spring的Bean定义模型，通过增加Spring的Bean Handler处理以及Schema的限制，实现DataSet的定义。
    
    在XML中定义的DataSet，其载入方式与Spring ApplicationContext初始化方式一致，即每个DataSet即为一个Spring Bean。由于DataSet的数量众多，以及为了使应用的服务Bean与DataSet分开，DataSet的XML定义将遵循相应的命名规则一致载入。XML文件的命名规则为：
    
    ```
    resources/data/macula-base/XXX-dataset.xml
    ```
    ```xml
    <!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
    <span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain"></span><br />
    <span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">spring:beans</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">xmlns</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;http://www.maculaframework.org/schema/data&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">xmlns:spring</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;http://www.springframework.org/schema/beans&quot;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">xmlns:xsi</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">xsi:schemaLocation</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;</span><br />
    <span class="xml_attribute_value">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/beans&nbsp;http://www.springframework.org/schema/beans/spring-beans.xsd&nbsp;&nbsp;</span><br />
    <span class="xml_attribute_value">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.maculaframework.org/schema/data&nbsp;http://www.maculaframework.org/schema/data/macula-data.xsd&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataset</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">id</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TEST_XML_DATA_SET_CODE&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;XMLMnDataSetK�&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">expressionText</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">select&nbsp;*&nbsp;from&nbsp;MA_BASE_DATA_SET&nbsp;where&nbsp;code=#(code)#</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">expressionText</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataSource</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">macula_ds</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataSource</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataArgs</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataArg</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">label</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;�&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;code&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">String</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fieldControl</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">Text</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fieldControl</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataParam</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">TEST_PARAM_XX</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataParam</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataArg</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataArgs</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataset</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataset</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">id</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TEST_XML_DATA_SET_CODE2&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;XMLMnDataSetK�2&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">expressionText</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">select&nbsp;*&nbsp;from&nbsp;MA_BASE_DATA_SET&nbsp;where&nbsp;code=#(code)#</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">expressionText</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataSource</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">macula_ds</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataSource</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataArgs</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataArg</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">label</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;�&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;code&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dataType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">String</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fieldControl</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">Text</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fieldControl</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataArg</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataArgs</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dataset</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
    <span class="xml_plain"></span><br />
    <span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">spring:beans</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;&nbsp;</span><br />
    ```
    
3. 表达式引用

    可以通过在表达式中写入[ref=需要引用的其他DataSet的Code]的方式来进行引用。
    
## 16.5 数据集载入方式

为了统一数据集的载入方式，以及方便的定制以及扩展，Macula通过抽象载入接口，可通过实现该接口实现其他方式的载入。

```java
public interface DataLoader<T> extends Ordered {
	/**
	 * 根据code加载Data
	 * @param code 代码
	 * @return T
	 */
	public T loader(String code);

	/**
	 * 将缓存的data清除
	 */
	public void refresh();
}
```


        
        
        


